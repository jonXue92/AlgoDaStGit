# 数据结构
1.一个数据怎么组织的时候，其实是跟这个数据的规模有关系的
***2.解决问题方法的效率，跟数据的组织方式是直接相关的***

### question1: 
answer1:可以按照大类 小类 首字母排序的方式。比如工科类--计算机类--数据结构 这种形式，其实就是一个树的结构，通过层级划分，来限定更窄的范围，然后取得想要的数据。
   基于上面的考虑针对摆放图书这样的问题，实际上还有很多其他问题出现:
   如何选择畅销书的摆放位置？ 可能这类书籍更频繁地被查找。(其实也就是如何根据使用频率来进行分类)
   类别的细化如何进行？ 可能在某种分类之下，某一本书的类别存在交叉现象，那么我们要么需要限定某个类别进行位置摆放，要么重新对类别进行细化分类。
   上面两个点交叉的话对于下架某本或者某类图书也是不利的，例如我们需要删除数据结构这本书，但是他在畅销书中，这个时候可能既需要下架畅销书区域的数据结构，还需要下架计算机类下的数据结构，这也会造成两个分类之间的耦合，包括添加也是。

answer2:由于学科细分程度所消耗的时间和找到目标图书的时间，是负相关的。所以我觉得，得结合实际情况（比如实际的藏书量和访客量），来确定图书分类的详细程度，达到一个综合的效率最大值。

**answer3:大规模数据的最大问题就是兼顾插入、查找、删除的效率问题。对于静态数据的查找可以采用二叉排序树，使得查找效率可达logn。但问题就是如何在不断更新数据的时候，使二叉树高度也即查找效率保持logn级别，例如如果根结点不变，而之后所有的插入按关键字递增排序，那么树高将变为o(n)级别，BST优势不复存在。因此可以使用平衡二叉树，使的每个结点左右两子树高度差(即平衡因子)的绝对值小于等于1，以此来保证查找的效率。当新的一次插入后，从插入点向上依次计算每一个父结点的平衡因子，根据平衡因子的值，以及插入点在其子树中的左右位置分别进行LL、LR、RR、RL旋转。但是AVL树是一种高度平衡的树，每一次对树的修改都要开销较大的再平衡，对于插入删除较频繁的数据反而降低了效率，因此也可以使用折中的红黑树。红黑树的查找效率最大为2logn,但不如AVL树频繁的再平衡。红黑树是通过对树中的每一个结点“染色”，即，对每一个结点一个额外的属性color，用来标记该结点的颜色红黑树包括5条性质，1结点的颜色非黑即红，2根结点必为黑，3所有叶结点(NIL)都是黑色的，4如果某个结点是红，则其两个孩子都为黑，5从任意结点出发，到其所有后代叶结点的简单路径上，黑色结点的数目相同，也即黑高相等。这5条性质保证了红黑树的查找长度最大为2h，其中h为黑高。虽然红黑树牺牲了些许查找效率，但大大提高了插入删除的效率，C++中许多STL底层就是用红黑树实现的**

***3.解决问题方法的效率，也跟空间的利用效率是有关的***
*4.f(x)=a0+x(a1+x(a2+x(...(an-1+x(an))...)))*
***5.解决问题方法的效率，还跟算法的巧妙程度是有关的***

6.数据结构
(1)数据对象在计算机中的组织方式
   逻辑结构：线性结构和树型结构
   物理存储结构：
(2)数据对象必定与一系列加在其上的操作相关联
(3)完成这些操作所用的方法就是算法

7.抽象数据类型(Abstract Data Type)
   数据类型
      数据对象集
      数据集合相关联的操作集
   抽象：描述数据类型的方法不依赖于具体实现
      与存放数据的机器无关
      跟数据存储的物理结构无关
      跟实现操作的算法和编程语言均无关
只描述数据对象集和相关的操作集“是什么”，并不涉及“它是如何做到的”的问题

**8.抽象可以在宏观程度上把握程序的整体架构，而不用考虑程序实现的具体细节。
   更具有普遍适用性，不用去细化细节，从具体事物抽出、概括出它们共同的方面、本质属性与关系等，而将个别的、非本质的方面、属性与关系舍弃
   抽象是面向对象编程的一个特性，我认为抽象是在抓主要矛盾，忽略成员的细枝末节，可以为调用程序提供一个统一的接口，利于整个算法系统的维护。Windows 里面的硬件抽象层(HAL)就是这样，为调用硬件的程序提供了一个统一的接口，这样对于新硬件只需要修改相应的驱动，而不用修改上层的程序。**
   
# 算法(Algorithm)
   一个有限的指令集
   接受一些输入（有些情况下不需要输入）
   产生输出
   一定在有限步骤之后终止
   每一条指令必须：
      有充分明确的目标，不可以有歧义
      计算机能处理的范围之内
      描述应不依赖于任何一种计算机语言以及具体的实践手段

好的算法：
1.空间复杂度S(n):根据算法写成的程序在执行时占用存储单元的长度
2.时间复杂度T(n):根据算法写成的程序在执行时耗费时间的长度

1.最坏情况的复杂度Tworst(n)
2.平均的复杂度Tavg(n)(问题是：什么是平均？)
Tavg(n)<=Tworst()

### question2:
（迭代法）二分查找递增有序链表L中的特定值X
{
    当左边界点low不大于右边界点high时
    {
        取中间点mid；
        如果 X等于位于中间点mid的值
            返回 位置mid；
        再如果 X大于位于中间点mid的值
            左边界点更改为mid右边的一个点；
        再如果 X小于位于中间点mid的值
            右边界点更改为mid左边的一个点；
    }
    返回 未找到
}
    使用迭代法的二分查找，辅助空间是常数级别的:空间占用区域一个数组，三个变量位置，在每次循环结束后都会随之释放，并不会产生改变,所以空间复杂度始终为O(1)；最好情况下是一次能找到待查找值，所以时间复杂度是O(1)，最坏情况下，是一直查找（例如待查找值是小于左边界的一个值），每次查找会排除一半的数据，所以根据计算，时间复杂度为O(log(n))。

复杂度的渐进表示法：
T(n)=O(f(n))表示存在常数C>0,n0>0使得当n>=n0时有T(n)<=C.f(n)
T(n)=Ω(g(n))表示存在常数C>0,n0>0使得当n>=n0时有T(n)>=C.g(n)
T(n)=big theta(h(n))表示同时有T(n)=O(h(n))和T(n)=Ω(h(n))

1.算法拼接：
T1(n)+T2(n)=max(O(f1(n)),O(f2(n)))
2.算法嵌套：
T1(n)\*T2(n)=O(f1(n)\*f2(n))
3.若T(n)是关于n的k阶多项式，那么T(n)=big theta(n^k)
4.for循环：循环次数×循环体内代码复杂度
5.if-else：if条件判断复杂度和两个分支的复杂度，取三者最大

最大子列和问题：在线处理算法