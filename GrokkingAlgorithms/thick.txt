二分查找的速度比简单查找快得多。
O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。

大O表示法让你能够比较操作数，它指出了算法运行时间的增速 。

计算机内存犹如一大堆抽屉。
需要存储多个元素时，可使用数组或链表。
数组的元素都在一起。
链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
数组的读取速度很快。
链表的插入和删除速度很快。
在同一个数组中，所有元素的类型都必须相同（都为int、double等）。

递归
1.调用自己的函数
2.条件： 基线（退出）条件（base case）＋递归条件（recursive case）

栈：
1.两种操作： 压入和弹出
2.所有函数调用都进入调用栈 
3.后进先出LIFO。
4.调用栈可能很长，这将占用大量的内存。

快排
1.使用分而治之策略
	分而治之（D&C）问题解决问题的两个步骤：
	1.找出基线条件，此条件尽可能简单
	2.不断分解问题，知道满足基线条件 
备注：
1.D&C不是解决问题的办法，而是解决问题的思路。
2.D&C处理列表时，基线条件很可能是空列表或者只包含一个元素。

实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。
大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。
比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。

散列表：
你可以结合散列函数和数组来创建散列表。
散列表的查找、插入和删除速度都非常快。
散列表适合用于模拟映射关系。
一旦填装因子超过0.7，就该调整散列表的长度。
散列表可用于缓存数据（例如，在Web服务器上）。
散列表非常适合用于防止重复。

1.处理冲突的方式的简单办法，如果两个键映射到同一个位置，可在该位置存储一个链表。
2.目的是要将键均匀的映射到散列表的不同位置处。
3.避免冲突：
	3.1.较低的填装因子
	填装因子＝散列表保护元素数／位置总数，度量散列表中多少位置是空的。填装因子月底，冲突可能性越小，散列表性能越高。经验：一旦填装因子大于0.7，就调整散列表长度。
	3.2.良好的散列函数
4.可用来表示图关系。

广度优先搜索BFS：
1.广度优先搜索指出是否有从A到B的路径。如果有，广度优先搜索将找出最短路径。
2.面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。
3.运行时间：O（人数＋边数），通常为O（V+E），V为顶点数，E为边数。
4.你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径。因此搜索列表必须是队列。
5.对于检查过的人，不需要再检查，否则会造成无限循环。


队列 
1.先进先出，FIFO，按添加顺序进行检查
2.栈是后进先出（LIFO）的。

图：
1.有向图中的边为箭头，箭头的方向指定了关系的方向
2.无向图中的边不带箭头，其中的关系是双向的

拓扑排序：
1.列表中任务A必须在任务B后面，这成为拓扑排序。
2.使用它可根据图创建一个有序列表。

1.计算非加权图的最短路径是广度优先搜索，计算加权图的最短路径是狄克斯特拉算法
2.狄克斯特拉算法只适用于有向无环图 （directed acyclic graph，DAG）
3.狄斯特拉算法的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径 ！
4.不能将狄克斯特拉算法用于包含负权边的图。
5.在包含负权边的图中，要找出最短路径，可使用另一种算法——贝尔曼-福德算法 （Bellman-Ford algorithm）
6.实现：三个散列表（graph(多维散列表),cost,parent）
7.四步骤：
	7.1.找到最便宜的节点
	7.2.对于该节点的邻居，检查是否有通往他们的更短路径，如果有，更新其开销
	7.3.重复这个过程，直到所有节点都这样做了
	7.4.计算最终路径
	
没有快速算法的问题（NP完全问题）
识别NP完全问题，以免浪费时间去寻找解决它们的快速算法。
近似算法，使用它们可快速找到NP完全问题的近似解。
贪婪策略——一种非常简单的问题解决策略。

旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。

1.元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
2.涉及“所有组合”的问题通常是NP完全问题。
3.不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
4.如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。
5.如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。
6.如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。
对于NP完全问题，还没有找到快速解决方案。
面临NP完全问题时，最佳的做法是使用近似算法。
贪婪算法易于实现、运行速度快，是不错的近似算法。

动态规划
每次迭代时，你都存储当前的最大价值。最大价值不可能比以前低！
考虑的粒度！！
但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用！！

1.动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。
2.在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。

1.每种动态规划解决方案都涉及网格。
2.单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。
3.每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴

绘制网格
用于解决这个问题的网格是什么样的呢？要确定这一点，你得回答如下问题。
1.单元格中的值是什么？
2.如何将这个问题划分为子问题？
3.网格的坐标轴是什么？
4.在动态规划中，你要将某个指标最大化。

git diff 等命令吗？它们指出两个文件的差异，是使用动态规划实现的。
编辑距离 （levenshtein distance）指出了两个字符串的相似程度，使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。
Microsoft Word等具有断字功能的应用程序如何确定在什么地方断字以确保行长一致呢？使用动态规划！

没有放之四海皆准的计算动态规划解决方案的公式。

K最近邻 （k-nearest neighbours，KNN）算法
归一化（normalization）
权重问题

合适的特征，就是：
 
与要推荐的电影紧密相关的特征；
不偏不倚的特征（例如，如果只让用户给喜剧片打分，就无法判断他们是否喜欢动作片）。
如果有N位用户，应考虑sqrt(N)个邻居。

垃圾邮件过滤器：朴素贝叶斯分类器（计算是垃圾邮件的概率）

KNN用于分类和回归，需要考虑最近的邻居。
分类就是编组。
回归就是预测结果（如数字）。
特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。
能否挑选合适的特征事关KNN算法的成败。

二叉查找树(binary search tree)：不能随机访问
对于其中的每个节点，左子节点的值都比它小 ，而右子节点的值都比它大 。
在二叉查找树中查找节点时，平均运行时间为O (log n )，但在最糟的情况下所需时间为O (n )；
而在有序数组中查找时，即便是在最糟情况下所需的时间也只有O (log n )
因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。

B树是一种特殊的二叉树，数据库常用它来存储数据。
如果你对数据库或高级数据结构感兴趣，请研究如下数据结构：B树，红黑树，堆，伸展树。

一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引 （inverted index），常用于创建搜索发动机。

傅立叶变换：
1.给定歌曲，将其中各种频率分离出来。

并行性管理开销 。如何在两个内核之间这项任务呢？合并也是需要时间的。
负载均衡 。但分配给内核A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。你如何均匀地分配工作，让两个内核都一样忙呢？

分布式算法
MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。

假设你有一个数据库表，包含数十亿乃至数万亿行，需要对其执行复杂的SQL查询。在这种情况下，
你不能使用MySQL，因为数据表的行数超过数十亿后，它处理起来将很吃力。相反，
你需要通过Hadoop来使用MapReduce！

分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：
映射（map ）函数和归并（reduce ）函数。

映射函数
它接受一个数组，并对其中的每个元素执行同样的处理
归并函数
归并函数其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。

MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。

布隆过滤器是一种概率型数据结构 ，它提供的答案有可能不对，但很可能是正确的。
可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。
不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。
布隆过滤器的优点在于占用的存储空间很少。
使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。
HyperLogLog
面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！

安全散列算法（secure hash algorithm，SHA）函数。给定一个字符串，SHA返回其散列值。
SHA是一个散列函数 ，它生成一个散列值 ——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。

SHA被广泛用于计算密码的散列值。这种散列算法是单向的。你可根据字符串计算出散列值。但你无法根据散列值推断出原始字符串。
当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。
SHA还有一个重要特征，那就是局部不敏感的。假设你有一个字符串，并计算了其散列值。
如果你修改其中的一个字符，再计算其散列值，结果将截然不同

使用Simhash。如果你对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。这让你能够通过比较散列值来判断两个字符串的相似程度，这很有用！

Google使用Simhash来判断网页是否已搜集。
老师可以使用Simhash来判断学生的论文是否是从网上抄的。
需要检查两项内容的相似程度时，Simhash很有用。

Diffie-Hellman密钥交换
如何对消息进行加密，以便只有收件人才能看懂呢？
双方无需知道加密算法。他们不必会面协商要使用的加密算法。
要破解加密的消息比登天还难。
Diffie-Hellman使用两个密钥：公钥和私钥。顾名思义，公钥就是公开的，可将其发布到网站上，
通过电子邮件发送给朋友，或使用其他任何方式来发布。你不必将它藏着掖着。有人要向你发送消息时，
他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道私钥，就只有你才能解密消息！
Diffie-Hellman算法及其替代者RSA依然被广泛使用。如果你对加密感兴趣，先着手研究Diffie-Hellman算法是不错的选择：它既优雅又不难理解。

所有的图算法都可使用线性规划来实现。线性规划是一个宽泛得多的框架，图问题只是其中的一个子集。但愿你听到这一点后心潮澎湃！